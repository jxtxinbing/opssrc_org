# OpenSwitch schema format

This file describes the changes made to the schema, along with an explanation of
the files that are generated by this module.

Original discussion about the ***Schema Modularity*** started in
[this ops-dev mailing list thread](http://lists.openswitch.net/pipermail/ops-dev/2016-February/001731.html).
Even when the final implementation deviated from the original discussion, this
still serves as a reference to understand the use cases.

The original schema file was split into the small components using an automated
process. These pieces are now the new OpenSwitch schema; a logical-organized
collection of files containing a table definition each.

**Note**

The new schema pieces were conviniently generated using a proper JSON
indentation. Keep the same format when writing your own schemas.

## Table of content

1. [Definitions](#Definitions)
1. [Rationale](#Rationale)
  * [Schema readability](Schema readability)
  * [Schema validation](#Schema validation)
  * [Code generation](#Code generation)
  * [Database documentation](#Database documentation)
1. [Directory structure](#Directory structure)
1. [New schema format](#New schema format)
  * [Master and Unified schema](#Master and Unified schema)
  * [`emptyValue` element](#`emptyValue` element)
  * [`group` element](#`group` element)
  * [`doc` element](#`doc` element)
  * [`valueMap` element](#`valueMap` element)
  * [`valueType` element](`valueType` element)
1. [Validation](#Validation)
1. [Code generation](#Code generation)


## Definitions
| Term | Description
|---
| OVS  | Open vSwitch
| OPS  | OpenSwitch
| ovsschema | OVS schema
| extschema |  OPS schema. Also known as *extended schema*. It is an OpenSwitch version of the ovsschema which contains additional JSON elements to enable extended REST functionalities
| metaschema | set of rules described in JSON to validate the schema


## Rationale

### Schema readability

OpenSwitch schema contains many tables to meet feature-specific
requirements. Keeping all that tables in a single big file is too difficult to
read, understand, and maintain. Since the schema is being described using
JavaScript Object Notation (JSON),
[JSON Pointers](https://tools.ietf.org/html/rfc6901) can be used to create
references to elements in other files to split the original content into
smaller pieces.

Original Open vSwitch schema is complemented with a XML file to document the
tables and columns and describe the keys names and the values data types in
the maps. It is hard to match the table structure in the schema with the
semantics described in the XML file.

### Schema validation

Schema resides in its own repository. However, ops-openvswitch performs
validations in the schema structure using simple heuristics written in a Python
script. Such validations are done when the ops-openvswitch module is built.
However, the schema must be validated as soon as the changes get the
repository, instead of depending on the validation rules in the other
repository. Schema validation must be done during the `check` job and a similar
mechanism must be provided for the developer to be able to catch the errors
promptly.

Since the database schema uses JSON format, the validation process can be done
using a [meta-schema](https://tools.ietf.org/html/draft-zyp-json-schema-04) to
describe the general structure of the schema file. Main validation rules can be
described using the same JSON based format to also ease the understanding of
such rules.

### Code generation

All the symbols in the schema must be available for the feature daemons
code. Given some map columns names were only defined in the XML file, some
symbols were not being generated. Developers had to manually maintain a file
to make them available during the build process.

`emptyValue` element introduced in the new schema format must also generate the
correspondent symbols to let the feature daemon use it in the code.

### Database documentation

A diagram/graph can be built to ease the readability and understanding of the
semantics described in the schema. By using the `refTable` and `refType` tags,
the diagram can provide a picture of how the tables relate and depend on each
other. Given the schema has several tables with *complex relationships*, a
single diagram containing everything is impossible to read. Therefore, diagrams
are split per table, showing the connections to the other ones explicitly
related via `refTable` keyword.

Documentation must be easily navigated using Markdown or HTML files. Generated
files can be used locally or installed in **TODO: put the location here**.


## Directory structure

schema/
├── bin
├── lib
├── legacy
├── configdb
├── dhcp_leases
├── openswitch
│   └── common
└── vtep

* `schema` contains directories grouping the schema definition files by database.
  It also hosts schema-related scripts and libraries.
  * `bin`: supporting scripts to generate a consolidated `openswitch` database
    schema and validate it.
  * `lib`: Python libraries to complement the scripts functionalities.
  * `legacy`: deprecated C header files defining schema related constant values
    to be removed once remaining code refereces get revised to use the C constant
    values auto-generated by the `ops-openvswitch` module.
  * `configdb`: Configuration database schema.
  * `dhcp_leases: DHCP leases database schema.
  * `vtep`: VTEP database schema.
  * `openswitch`: OpenSwitch database schema.


## Schema format

### Master and Unified files

The **master.extschema.json** is a JSON file containing the references to the
tables that compose the database schema. It also contains a reference to the
group documentation. This master file is the one used by the scripts to create
an unified file where the references are resolved.

The **unified.extschema.json** file is not part of the repository because is a
generated file during the build process. Although, the unified file is deployed
as part of the image since `ops-restd` uses it instead of the old extschema.

```javascript
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "id": "master.extschema.json#",
  "name": "OpenSwitch",
  "version": "0.1.8",
  "groups": {
    "$ref": "docs/groups.extschema.json#/groups"
  },
  "tables": {
    "System": {
      "$ref": "common/system.json#/tables/System"
    },
    "Subsystem": {
      "$ref": "common/subsystem.json#/tables/Subsystem"
    },
    "Bridge": {
      "$ref": "common/bridge.json#/tables/Bridge"
    }
    # More tables...
  }
}
```
Note that JSON pointers are used to create a link to the specific elements on
the target file. Thus, the content of the `System` table was extracted from the
original `System` element inside of the `tables` element, into the `system.json`
file into the `common` directory.

### `emptyValue` element

This element describe the value to be used in case an optional column or a map
key is not set. It lets the developer know the value of an element when
it is not present in a notification. Thus, daemons do not have to hardcode the
value in its side because the info can be extracted from the schema.

The empty values are being generated as a C header file as part of this
module's build process in the `ops-empty-values.h` file.

> **TODO**: `emptyValue` must be integrated in the ovsdb_idl_class static data
structure to make them available in runtime, as the max/min,
maxInteger/minInteger, and maxLength/minLength are.

#### Format
```javascript
"emptyValue": <JSON-value>
```

> `<JSON-value>` must be specified using a valid JSON data type. `emptyValue`
> data type is defined by the column's `type` element or map's `valueType`
> element.

### `group` element

This element is used to put the tables/columns/maps inside a specific group.
It defines a logical grouping to put the schema element together, to ease the
understanding of the semantics described in the database schema.

To create a group, use the same hierarchical string tag in more than one
database schema element within the same category (you cannot put elements in
the same group if they are located in different tables, columns, or maps).

Optionally, the group may have a general description in
`docs/groups.extschema.json`.

#### Format
```javascript
"group": <string>
```

> Given the group value is a simple string, any valid character is allowed
> here. Hierarchical organization allows to detail each element to add
> descriptions to the group when the documentation is generated.

### `doc` element

This element contains the documentation of a table, column, map, or group. The
original HTML content in the XML file was converted into Markdown format and
added as an array of lines.

#### Format
```javascript
"doc": [
  <string>,
  <string>,
  ...
]
```

> Documentation lines were wrapped to *80 characters per line*. Keep the same
> format when adding more lines, no matter how many lines


### `valueMap` element

This new element is used to specify the key names in a column map and the
details related to them. It merges the information in the old schema and the
documentation in the old XML file. It is located under the `type` element in
column.

```javascript
"valueMap": {
  "key_1": {
    "type": <JSON-datatype>,
    "doc": [
      "line 1",
      "line 2"
    ],
    "group": "/Path/To/Group"
  },
  "key_2": {
    "type": {
      "type": "integer",
      "minInteger": <JSON-value>,
      "maxInteger": <JSON-value>
    },
    "doc": [
      "line 1"
    ],
    "group": "/Path/To/Group",
    "emptyValue": <JSON-value>
  }

```


### `valueType` element

This element describes the data type to be used in the entire map. Given the map
elements can define its own specific data type internallly for each key name,
this element allows to define a data type for every element in the map (required
for code generation).

#### Format
```javascript
"valueType": <string>
```


## Validation

The meta-schema to perform the validation is stored in `ops.metaschema.json`.

## Code generation

`ops-oenvswitch` provides a mechanism to generate the code to let the daemons
know about the definitions in the schema (enumerations, map keys). These values
are generated in the `vswitch-idl.h` file during the `ops-openswitch` build
process.

However, since the `emptyValue` element was introduced by OPS, `ops-openvswitch`
cannot generate the definitions for them. Therefore, a script was provided to
generate a header file per database (`<database>_empty_values.h`) containing
such values.
